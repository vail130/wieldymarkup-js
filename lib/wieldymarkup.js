// Generated by CoffeeScript 1.3.3
(function() {
  var WieldyMarkup, exports, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  _.str = require('underscore.string');

  WieldyMarkup = (function() {

    WieldyMarkup.whitespace = " \t";

    WieldyMarkup.removeGroupedText = function(text, z) {
      var grouperIndex, output, status;
      output = "";
      status = true;
      while (text !== '') {
        grouperIndex = text.indexOf(z);
        if (grouperIndex === -1) {
          if (status) {
            output += text;
          }
          text = '';
        } else {
          if (status) {
            output += text.substring(0, grouperIndex);
          }
          if (text.length > grouperIndex + 2) {
            text = text.substring(grouperIndex + 1, text.length);
          } else {
            text = '';
          }
        }
        status = !status;
      }
      return output;
    };

    WieldyMarkup.getSelectorFromLine = function(line) {
      var ch, firstWhitespaceIndex, i, _i, _len, _ref;
      firstWhitespaceIndex = null;
      _ref = line.split("");
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        ch = _ref[i];
        if (WieldyMarkup.whitespace.indexOf(ch) > -1) {
          firstWhitespaceIndex = i;
          break;
        }
      }
      if (firstWhitespaceIndex === null) {
        return line;
      } else {
        return line.substring(0, firstWhitespaceIndex);
      }
    };

    WieldyMarkup.getTagNestLevel = function(text, openString, closeString) {
      var closeStringFirst, closeStringIndex, nest_level, openStringFirst, openStringIndex;
      if (openString == null) {
        openString = '<';
      }
      if (closeString == null) {
        closeString = '>';
      }
      nest_level = 0;
      while (true) {
        openStringIndex = text.indexOf(openString) > -1 ? text.indexOf(openString) : null;
        closeStringIndex = text.indexOf(closeString) > -1 ? text.indexOf(closeString) : null;
        openStringFirst = false;
        closeStringFirst = false;
        if (openStringIndex === closeStringIndex) {
          break;
        } else if (openStringIndex !== null) {
          openStringFirst = true;
        } else if (closeStringIndex !== null) {
          closeStringFirst = true;
        } else {
          if (openStringIndex < closeStringIndex) {
            openStringFirst = true;
          } else {
            closeStringFirst = true;
          }
        }
        if (openStringFirst) {
          nest_level++;
          if (text.length === openStringIndex + openString.length) {
            break;
          } else {
            text = text.substring(openStringIndex + openString.length, text.length);
          }
        } else if (closeStringFirst) {
          nest_level--;
          if (text.length === closeStringIndex + closeString.length) {
            break;
          } else {
            text = text.substring(closeStringIndex + closeString.length, text.length);
          }
        }
      }
      return nest_level;
    };

    WieldyMarkup.getLeadingWhitespaceFromText = function(text) {
      var ch, i, leadingWhitespace, _i, _len, _ref;
      leadingWhitespace = "";
      _ref = text.split("");
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        ch = _ref[i];
        if (WieldyMarkup.whitespace.indexOf(ch) === -1) {
          leadingWhitespace = text.substring(0, i);
          break;
        }
      }
      return leadingWhitespace;
    };

    function WieldyMarkup(text, compress) {
      if (text == null) {
        text = "";
      }
      if (compress == null) {
        compress = false;
      }
      this.addHtmlToOutput = __bind(this.addHtmlToOutput, this);

      this.processAttributes = __bind(this.processAttributes, this);

      this.processSelector = __bind(this.processSelector, this);

      this.processEmbeddedLine = __bind(this.processEmbeddedLine, this);

      this.processNextLine = __bind(this.processNextLine, this);

      this.closeTag = __bind(this.closeTag, this);

      this.closeLowerLevelTags = __bind(this.closeLowerLevelTags, this);

      this.processCurrentLevel = __bind(this.processCurrentLevel, this);

      this.text = text;
      this.compress = compress;
      this.compile();
    }

    WieldyMarkup.prototype.compile = function(text, compress) {
      if (text == null) {
        text = null;
      }
      if (compress == null) {
        compress = null;
      }
      if (text !== null) {
        this.text = text;
      }
      if (compress !== null) {
        this.compress = !!compress;
      }
      this.output = "";
      this.openTags = [];
      this.indentToken = "";
      this.currentLevel = 0;
      this.previousLevel = null;
      this.lineNumber = 0;
      this.embeddingToken = '`';
      while (this.text !== "") {
        this.processCurrentLevel().closeLowerLevelTags().processNextLine();
      }
      while (this.openTags.length > 0) {
        this.closeTag();
      }
      return this;
    };

    WieldyMarkup.prototype.processCurrentLevel = function() {
      var i, leadingWhitespace;
      this.previousLevel = this.currentLevel;
      leadingWhitespace = this.constructor.getLeadingWhitespaceFromText(this.text);
      if (leadingWhitespace === "") {
        this.currentLevel = 0;
      } else if (this.indentToken === "") {
        this.indentToken = leadingWhitespace;
        this.currentLevel = 1;
      } else {
        i = 0;
        while (_.str.startsWith(leadingWhitespace, this.indentToken)) {
          leadingWhitespace = leadingWhitespace.substring(this.indentToken.length, leadingWhitespace.length);
          i += 1;
        }
        this.currentLevel = i;
      }
      return this;
    };

    WieldyMarkup.prototype.closeLowerLevelTags = function() {
      if (this.currentLevel <= this.previousLevel) {
        while (this.openTags.length > 0 && this.openTags[this.openTags.length - 1][0] >= this.currentLevel) {
          this.closeTag();
        }
      }
      return this;
    };

    WieldyMarkup.prototype.closeTag = function() {
      var closingTagTuple;
      closingTagTuple = this.openTags.pop();
      if (!this.compress && closingTagTuple[0] > 0) {
        this.output += _.str.repeat(this.indentToken, closingTagTuple[0]);
      }
      this.output += "</" + closingTagTuple[1] + ">";
      if (!this.compress) {
        this.output += "\n";
      }
      return this;
    };

    WieldyMarkup.prototype.processNextLine = function() {
      var line, lineBreakIndex, lineSplitList, restOfLine, selector, temp_line;
      this.lineStartsWithTick = false;
      this.selfClosing = false;
      this.innerText = null;
      line = "";
      if (__indexOf.call(this.text, "\n") >= 0) {
        lineBreakIndex = this.text.indexOf("\n");
        line = _.str.trim(this.text.substring(0, lineBreakIndex));
        this.text = this.text.substring(lineBreakIndex + 1, this.text.length);
      } else {
        line = _.str.trim(this.text);
        this.text = "";
      }
      this.lineNumber += 1;
      if (line.length === 0) {
        return this;
      }
      if (line[0] === this.embeddingToken) {
        this.processEmbeddedLine(line);
      } else {
        lineSplitList = line.split('\\-\\');
        while (lineSplitList.length > 1) {
          temp_line = _.str.trim(lineSplitList.shift());
          selector = this.constructor.getSelectorFromLine(temp_line);
          this.processSelector(selector);
          restOfLine = _.str.trim(temp_line.substring(selector.length, temp_line.length));
          restOfLine = this.processAttributes(restOfLine);
          this.addHtmlToOutput();
          this.tag = null;
          this.tagId = null;
          this.tagClasses = [];
          this.tagAttributes = [];
          this.previousLevel = this.currentLevel;
          this.currentLevel++;
        }
        line = _.str.trim(lineSplitList[lineSplitList.length - 1]);
        selector = this.constructor.getSelectorFromLine(line);
        this.processSelector(selector);
        restOfLine = _.str.trim(line.substring(selector.length, line.length));
        restOfLine = this.processAttributes(restOfLine);
        if (_.str.startsWith(restOfLine, '<')) {
          this.innerText = restOfLine;
          if (this.constructor.getTagNestLevel(this.innerText) < 0) {
            throw "Too many '>' found on line " + this.lineNumber;
          }
          while (this.constructor.getTagNestLevel(this.innerText) > 0) {
            if (this.text === "") {
              throw "Unmatched '<' found on line " + this.lineNumber;
            } else if (__indexOf.call(this.text, "\n") >= 0) {
              lineBreakIndex = this.text.indexOf("\n");
              this.innerText += ' ' + _.str.trim(this.text.substring(0, lineBreakIndex));
              if (this.text.length === lineBreakIndex + 1) {
                this.text = "";
              } else {
                this.text = this.text.substring(lineBreakIndex + 1, this.text.length);
              }
            } else {
              this.innerText += this.text;
              this.text = "";
            }
          }
          this.innerText = _.str.trim(this.innerText).substring(1, this.innerText.length - 1);
        } else if (_.str.startsWith(restOfLine, '/')) {
          if (restOfLine.length > 0 && restOfLine[restOfLine.length - 1] === '/') {
            this.selfClosing = true;
          }
        }
        this.addHtmlToOutput();
      }
      return this;
    };

    WieldyMarkup.prototype.processEmbeddedLine = function(line) {
      this.lineStartsWithTick = true;
      if (!this.compress) {
        this.output += _.str.repeat(this.indentToken, this.currentLevel);
      }
      this.output += line.substring(1, line.length);
      if (!this.compress) {
        this.output += "\n";
      }
      return this;
    };

    WieldyMarkup.prototype.processSelector = function(selector) {
      var ch, delimiterIndex, i, nextDelimiterIndex, _i, _j, _len, _len1, _ref, _ref1;
      if (selector.length > 0 && ((_ref = selector[0]) === '#' || _ref === '.')) {
        this.tag = 'div';
      } else {
        delimiterIndex = null;
        _ref1 = selector.split("");
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          ch = _ref1[i];
          if (ch === '#' || ch === '.') {
            delimiterIndex = i;
            break;
          }
        }
        if (delimiterIndex === null) {
          this.tag = selector;
          selector = "";
        } else {
          this.tag = selector.substring(0, delimiterIndex);
          selector = selector.substring(this.tag.length, selector.length);
        }
      }
      this.tagId = null;
      this.tagClasses = [];
      while (true) {
        nextDelimiterIndex = null;
        if (selector === "") {
          break;
        } else {
          for (i = _j = 0, _len1 = selector.length; _j < _len1; i = ++_j) {
            ch = selector[i];
            if (i > 0 && (ch === '#' || ch === '.')) {
              nextDelimiterIndex = i;
              break;
            }
          }
          if (nextDelimiterIndex === null) {
            if (selector[0] === '#') {
              this.tagId = selector.substring(1, selector.length);
            } else if (selector[0] === ".") {
              this.tagClasses.push(selector.substring(1, selector.length));
            }
            selector = "";
          } else {
            if (selector[0] === '#') {
              this.tagId = selector.substring(1, nextDelimiterIndex);
            } else if (selector[0] === ".") {
              this.tagClasses.push(selector.substring(1, nextDelimiterIndex));
            }
            selector = selector.substring(nextDelimiterIndex, selector.length);
          }
        }
      }
      return this;
    };

    WieldyMarkup.prototype.processAttributes = function(restOfLine) {
      var ch, closeIndex, currentAttribute, embeddedAttribute, equalsIndex, firstEqualsIndex, i, reversedLettersBetweenEquals, secondEqualsIndex, whitespaceIndex, _i, _len;
      this.tagAttributes = [];
      while (restOfLine !== "") {
        if (__indexOf.call(restOfLine, '=') < 0) {
          break;
        } else if (__indexOf.call(restOfLine, '=') >= 0 && __indexOf.call(restOfLine, '<') >= 0 && restOfLine.indexOf('<') < restOfLine.indexOf('=')) {
          break;
        }
        firstEqualsIndex = restOfLine.indexOf('=');
        embeddedAttribute = false;
        if (restOfLine.substr(firstEqualsIndex + 1, 2) === '{{') {
          embeddedAttribute = true;
          closeIndex = restOfLine.indexOf('}}');
          if (closeIndex === -1) {
            throw "Unmatched '{{' found in line " + this.lineNumber;
          }
        } else if (restOfLine.substr(firstEqualsIndex + 1, 2) === '<%') {
          embeddedAttribute = true;
          closeIndex = restOfLine.indexOf('%>');
          if (closeIndex === -1) {
            throw "Unmatched '<%' found in line " + this.lineNumber;
          }
        }
        if (embeddedAttribute) {
          currentAttribute = restOfLine.substring(0, closeIndex + 2);
          if (restOfLine.length === closeIndex + 2) {
            restOfLine = "";
          } else {
            restOfLine = restOfLine.substr(closeIndex + 2);
          }
        } else if (restOfLine.length === firstEqualsIndex + 1) {
          currentAttribute = _.str.trim(restOfLine);
          restOfLine = "";
        } else if (__indexOf.call(restOfLine.substr(firstEqualsIndex + 1), '=') < 0) {
          if (__indexOf.call(restOfLine, '<') >= 0) {
            currentAttribute = _.str.trim(restOfLine.substring(0, restOfLine.indexOf('<')));
            restOfLine = restOfLine.substr(restOfLine.indexOf('<'));
          } else {
            currentAttribute = restOfLine;
            restOfLine = "";
          }
        } else {
          secondEqualsIndex = restOfLine.substr(firstEqualsIndex + 1).indexOf('=');
          reversedLettersBetweenEquals = _.str.reverse(restOfLine.substring(firstEqualsIndex + 1, firstEqualsIndex + 1 + secondEqualsIndex));
          whitespaceIndex = null;
          for (i = _i = 0, _len = reversedLettersBetweenEquals.length; _i < _len; i = ++_i) {
            ch = reversedLettersBetweenEquals[i];
            if (" \t".indexOf(ch) > -1) {
              whitespaceIndex = firstEqualsIndex + 1 + secondEqualsIndex - i;
              break;
            }
          }
          if (whitespaceIndex === null) {
            break;
          }
          currentAttribute = _.str.trim(restOfLine.substring(0, whitespaceIndex));
          restOfLine = restOfLine.substr(whitespaceIndex);
        }
        if (currentAttribute !== null) {
          equalsIndex = currentAttribute.indexOf('=');
          this.tagAttributes.push((" " + (currentAttribute.substring(0, equalsIndex)) + "=") + ("" + ('"' + currentAttribute.substr(equalsIndex + 1) + '"')));
        }
      }
      return _.str.trim(restOfLine);
    };

    WieldyMarkup.prototype.addHtmlToOutput = function() {
      var tagHtml;
      if (!this.lineStartsWithTick) {
        tagHtml = "<" + this.tag;
        if (this.tagId !== null) {
          tagHtml += " id=\"" + this.tagId + "\"";
        }
        if (this.tagClasses.length > 0) {
          tagHtml += " class=\"" + this.tagClasses.join(' ') + "\"";
        }
        if (this.tagAttributes.length > 0) {
          tagHtml += this.tagAttributes.join('');
        }
        if (this.selfClosing) {
          tagHtml += " />";
          if (!this.compress) {
            this.output += _.str.repeat(this.indentToken, this.currentLevel);
          }
          this.output += tagHtml;
          if (!this.compress) {
            this.output += "\n";
          }
        } else {
          tagHtml += ">";
          if (this.innerText !== null) {
            tagHtml += this.innerText;
          }
          if (!this.compress) {
            this.output += _.str.repeat(this.indentToken, this.currentLevel);
          }
          this.output += tagHtml;
          if (this.innerText === null) {
            if (!this.compress) {
              this.output += "\n";
            }
            this.openTags.push([this.currentLevel, this.tag]);
          } else {
            this.output += "</" + this.tag + ">";
            if (!this.compress) {
              this.output += "\n";
            }
          }
        }
      }
      return this;
    };

    return WieldyMarkup;

  }).call(this);

  exports = module.exports = {
    version: '0.1.0',
    Compiler: WieldyMarkup
  };

}).call(this);
